import struct
import corpses # Seu arquivo de IDs de corpos

# Configurações baseadas no structures.h
OFFSET_MAP_POINTER = 0x1D4C20 # Confirme este valor no seu config.py (Base 0x400000)
TILE_SIZE = 172 # 4 bytes count + (14 * 12 bytes object)
MAX_X = 18
MAX_Y = 14
MAX_Z = 8

def get_map_address(pm, base_addr):
    """Lê o endereço base da estrutura Map_t."""
    return pm.read_int(base_addr + OFFSET_MAP_POINTER)

def read_tile_objects(pm, base_addr, rel_x, rel_y, rel_z=0):
    """
    Lê os objetos de um tile baseado na posição RELATIVA ao topo-esquerdo da memória.
    O Player geralmente está em X=8, Y=6 na memória (Centro).
    
    Args:
        rel_x, rel_y: Índices na matriz 18x14 (0 a 17, 0 a 13).
        rel_z: Andar relativo (0 a 7). Geralmente 0 é o andar atual se Z < 8? 
               Nota: Tibia 7.x costuma usar Z=0 como o andar do player na memoria plana.
    """
    map_start = get_map_address(pm, base_addr)
    
    # Cálculo do Offset: tiles[x][y][z] ou tiles[z][y][x]?
    # Baseado em structures.h: Tile_t tiles[18][14][8];
    # Em C++, arrays multidimensionais são Row-Major. A ordem é [18] -> [14] -> [8]
    # Offset = (x * 14 * 8 * TILE_SIZE) + (y * 8 * TILE_SIZE) + (z * TILE_SIZE)
    
    # AJUSTE IMPORTANTE: 
    # Em muitos clientes, a memória é acessada ciclicamente, mas vamos assumir linear para simplificar.
    # Se o resultado estiver errado, a ordem dos índices pode ser [z][y][x].
    # Testes em versões antigas indicam Z-Axis primeiro muitas vezes.
    # Vamos tentar a ordem linear visual: row (y) * width + col (x)
    # offset = ((rel_y * MAX_X) + rel_x) * TILE_SIZE 
    # (Ignorando Z por enquanto ou assumindo Z=0 para o andar do player)
    
    # Usando a lógica do structures.h estrito:
    # offset = (rel_x * 14 * 8 + rel_y * 8 + rel_z) * TILE_SIZE 
    
    # TENTATIVA RECOMENDADA (Layout Padrão Tibia Legacy):
    # O ponteiro de mapa aponta para o primeiro tile da tela (0,0).
    # O array é linear: Tile 0, Tile 1... Tile N.
    # Index = (rel_y * 18) + rel_x
    
    tile_index = (rel_y * 18) + rel_x
    tile_addr = map_start + (tile_index * TILE_SIZE)
    
    try:
        # Lê o Tile_t inteiro (172 bytes) de uma vez para performance
        tile_data = pm.read_bytes(tile_addr, TILE_SIZE)
    except:
        return [], 0

    # Parseia o 'amount' (primeiros 4 bytes)
    item_count = struct.unpack_from("<I", tile_data, 0)[0]
    
    # Parseia os objetos
    # Object_t = 12 bytes (ID, Data, DataEx)
    items = []
    
    # Limita leitura ao máximo de 14 ou ao count informado
    safe_count = min(item_count, 14)
    
    # O Tibia organiza a stack de baixo para cima? Ou o topo é o primeiro?
    # Geralmente: objects[0] = Ground. objects[1] = Item em cima.
    
    for i in range(safe_count):
        offset = 4 + (i * 12) # 4 bytes header + index * size
        if offset + 12 > len(tile_data): break
        
        item_id, data1, data2 = struct.unpack_from("<III", tile_data, offset)
        
        items.append({
            "id": item_id,
            "data": data1,
            "stack_pos": i # A posição no array É o stack_pos
        })
        
    return items, item_count

def find_corpse_stack_pos(pm, base_addr, dx, dy):
    """
    Retorna o stack_pos do corpo no tile relativo (dx, dy) do player.
    dx, dy: Distância do player (ex: 1, 0 = leste).
    """
    # Converter coordenada relativa (dx, dy) para índice da matriz (0..17, 0..13)
    # Player está no centro: 8, 6
    mem_x = 8 + dx
    mem_y = 6 + dy
    
    if not (0 <= mem_x < 18 and 0 <= mem_y < 14):
        return -1 # Fora da tela
        
    items, count = read_tile_objects(pm, base_addr, mem_x, mem_y)
    
    # Procura de trás para frente (do topo para baixo)
    # Ignora o último item se for efeito de magia (as vezes acontece)
    for i in range(len(items) - 1, -1, -1):
        item = items[i]
        
        # Verifica se o ID é um corpo conhecido
        # Precisamos varrer o dicionário corpses ou ter um set de IDs de corpos
        # Exemplo simples:
        if is_corpse(item["id"]): 
            return item["stack_pos"]
            
    return -1

def is_corpse(item_id):
    # Verifica se o ID está nos valores do dicionário corpses.py
    return item_id in corpses.CORPSE_IDS.values()